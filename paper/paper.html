<!DOCTYPE html><html><head>
      <title>RobustBlindVerification.jl: Emulating quantum verification with QuEST</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:////Users/jmille15/.vscode/extensions/shd101wyy.markdown-preview-enhanced-0.8.11/crossnote/dependencies/katex/katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="summary">Summary </h1>
<p>Utilising remote computation resources when local availability does not meet the users needs is currently in use for classical and cloud computing. It is likely that quantum computing will also be accessed and used as such. It is not unreasonable that computations, data and algorithms run on powerful quantum servers be confidential, free from harm and verifiable. Hence, delegated quantum computing is an important pathway to extending QC usefulness. Security protocols for blind and verifiable QC do exist and it has been shown that bounded-error quantum polynomial (BQP) computations can be verified with little overhead, other than computational repetitions, are composable and secure with toleration to constant noise, called Robust Blind Verified Quantum Computing (RBVQC). To emulate these known results, we introduce the Julia package, <code>RobustBlindVerification.jl</code> (RBV). RBV is a quantum verification emulator using Julia and the C library <code>QuEST</code> (for QC emulation and noise modelling). To explore the theoretical nature of RBVQC numerically, this software implements measurement based quantum computing (MBQC), universal blind MBQC (UBQC) and an RBVQC protocol.</p>
<p><strong>Refine and proof ... [@PRXQuantum.2.040302]</strong></p>
<h1 id="statement-of-need">Statement of need </h1>
<p>The rise of quantum computers gives rise to a variety of path dependent access points. Delegated quantum computing may likely be the dominant means most can use to access a quantum computer. One party's access may require secrecy in their computation. Another party, or the same, may need to verify results that computations are trustworty. Formal methods in quantum verification have been developed in theory. Many of these methods rely on quantum networks, mid-circuit measurement and qubit capabilities beyond the current near-term offering. In preparation for the aforementioned to become a reality, quanutm emulators offer cheap computational access in many toy problems, along with an ability to test theoretical results. High performance computation utilises multiple CPUs or GPUs to approach the arymptotic limit of classical computation in the emulation of the quantum computers.</p>
<p>Most verification protocols rely on MBQC, due to the ability to separate computational components through the use of projective measurements. Herein lies a pain point. Many quantum computers today do not readily offer mid-circuit measurement, which is key to MBQC. Furth there are few MBQC emulators, and the ones that do exist (CITE Grapix, others ...) do not consider the paradigm of RBVQC. Specifically, there is no impelementation to separate the concerns of the a so-call "client" and "server", nor is there the usage of interactive computation between two parties.</p>
<p>RBV is to-date (and at the authors undersatnding) the only emulator which implements a simulated blind quantum computation, let alone the verification protool [cite]. Many quantum computing emulators also only focus on the gate-based model, whilst some implement MBQC [Cite] many do not allow for noise models beyond uncorrelated models, which do not utilise density matrix backends. Many emulators are also focused on python-based libraries [cite]. RBV is based in Julia and calls on a C library. QuEST is a remarkable library that is capable of use agnostically to the machinery accessing the library.</p>
<p>What else ....<br>
Cite    .....</p>
<h1 id="core-features-and-functionality">Core features and functionality </h1>
<p>The root QC paradigm of RVBQC is MBQC. Hence, a user, after initial implementations, is able to run their given MBQC circuit and obtain noiseless results. Further, without impelementing the multiple rounds of the verification protocol, the user can take that same circuit and run it blindly. The main feature of RBV is the implementation of the protocol (<strong>CITE and reference in some consistent way</strong>). Here the user is able to run the protocol with no noise, uncorrelated noise, and specific noise models.</p>
<p>RBV uses QuEST, as has been mentioned. Further to this, QuEST was compiled into the Julia package QuEST_jll. This was done with BinaryBuilder.jl, and so is completely reproducible and even accessible from the Julia general registry, if users wish to have direct access. The package was compile with the default CMake options from the QuEST GitHub repository (cite). Further, we created QuEST.jl to specifically call all of the functions in the QuEST header file, making QuEST.jl a completely wrapped package for users to emulate other functions at their desire. [<strong>Needs to be completed and tested, or expression of limitations made</strong>] Users are able to also call multiple threads if needed in these computations. [<strong>What does this mean</strong>] As QuEST is runnable in HPC a future Julia release will include this functionality.</p>
<p>We present a basic tutorial on the usage of RBV along with targeted functions explained.</p>
<p>To begin, if not already done so, download and install Julia in your preferred method. Though lately JuliaUP is recommended. Then activate the Julia project of the local directory location</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code><span class="token keyword keyword-using">using</span> Pkg<span class="token punctuation">;</span> Pkg<span class="token punctuation">.</span>activate<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>
</code></pre><p>Add <code>RobustBlindVerification.jl</code></p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code><span class="token punctuation">]</span> add RobustBlindVerification
</code></pre><p>To run, first decide the computational backend, either a state vector or density matrix. These are <code>structs</code> named <code>StateVector</code> and <code>DensityMatrix</code>.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>state_type <span class="token operator">=</span> DensityMatrix<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><p>Choose the number of rounds and the number of computational rounds (the number of test rounds is the difference of computation from total).</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>total_rounds<span class="token punctuation">,</span>computation_rounds <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span><span class="token number">50</span>
</code></pre><p>RBV uses <code>Graphs.jl</code> and <code>MetaGraphs.jl</code>, so defining a graph uses that syntax. In this example we use the MBQC version of the 2 qubit Gover oracle algorithm.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    num_vertices <span class="token operator">=</span> <span class="token number">8</span>
    graph <span class="token operator">=</span> Graph<span class="token punctuation">(</span>num_vertices<span class="token punctuation">)</span>
    add_edge<span class="token operator">!</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
    add_edge<span class="token operator">!</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
    add_edge<span class="token operator">!</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>
    add_edge<span class="token operator">!</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span>
    add_edge<span class="token operator">!</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
    add_edge<span class="token operator">!</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>
    add_edge<span class="token operator">!</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>
    add_edge<span class="token operator">!</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>
</code></pre><p>We can specify any classical inputs to be loaded into the algorithm as well the output qubits.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    input <span class="token operator">=</span> <span class="token punctuation">(</span>indices <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>values <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    output <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>
</code></pre><p>There are algorithms for automatic flow detection, these have not been implemented, so the user defines a function for the so-called <em>forward flow</em>. The function is used to determine the <em>backward flow</em>.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    <span class="token keyword keyword-function">function</span> forward_flow<span class="token punctuation">(</span>vertex<span class="token punctuation">)</span>
        v_str <span class="token operator">=</span> string<span class="token punctuation">(</span>vertex<span class="token punctuation">)</span>
        forward <span class="token operator">=</span> Dict<span class="token punctuation">(</span>
            <span class="token string">"1"</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">,</span>
            <span class="token string">"2"</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token punctuation">,</span>
            <span class="token string">"3"</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">6</span><span class="token punctuation">,</span>
            <span class="token string">"4"</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">5</span><span class="token punctuation">,</span>
            <span class="token string">"5"</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">8</span><span class="token punctuation">,</span>
            <span class="token string">"6"</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">7</span><span class="token punctuation">,</span>
            <span class="token string">"7"</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">,</span>
            <span class="token string">"8"</span> <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span>
        forward<span class="token punctuation">[</span>v_str<span class="token punctuation">]</span>
    <span class="token keyword keyword-end">end</span>
</code></pre><p>Note: the internal structure of the <code>forward_flow</code> does not matter, as long as vertex input returns vertex output (<code>Int</code> type) and these values correspond to the graph, then the user can define its choice of I/O for that function.</p>
<p>The secret angles are defined next. For the Grover algorithm, the angles are curcial in its operation.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    <span class="token keyword keyword-function">function</span> generate_grover_secret_angles<span class="token punctuation">(</span>search<span class="token punctuation">::</span>String<span class="token punctuation">)</span>

        Dict<span class="token punctuation">(</span><span class="token string">"00"</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">*</span><span class="token constant">π</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token operator">*</span><span class="token constant">π</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"01"</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token operator">*</span><span class="token constant">π</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"10"</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token operator">*</span><span class="token constant">π</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"11"</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|&gt;</span>
        x <span class="token operator">-</span><span class="token operator">&gt;</span> x<span class="token punctuation">[</span>search<span class="token punctuation">]</span> <span class="token operator">|&gt;</span>
        x <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token operator">*</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token operator">*</span><span class="token constant">π</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token operator">*</span><span class="token constant">π</span><span class="token punctuation">]</span> <span class="token operator">|&gt;</span>
        x <span class="token operator">-</span><span class="token operator">&gt;</span> Float64<span class="token punctuation">.</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword keyword-end">end</span>
</code></pre><p>The function <code>generate_grover_secret_angles</code> defines the angles associated to each vertex in the <code>graph</code> which is dependent on the <code>search</code> input. Here we will define search as <code>11</code></p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    search <span class="token operator">=</span> <span class="token string">"11"</span>
    secret_angles <span class="token operator">=</span> generate_grover_secret_angles<span class="token punctuation">(</span>search<span class="token punctuation">)</span>
</code></pre><p>Names of inputs can vary, but they are all stored in a <code>NamedTuple</code> as</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    para<span class="token operator">=</span> <span class="token punctuation">(</span>
        graph<span class="token operator">=</span>graph<span class="token punctuation">,</span>
        forward_flow <span class="token operator">=</span> forward_flow<span class="token punctuation">,</span>
        input <span class="token operator">=</span> input<span class="token punctuation">,</span>
        output <span class="token operator">=</span> output<span class="token punctuation">,</span>
        secret_angles<span class="token operator">=</span>secret_angles<span class="token punctuation">,</span>
        state_type <span class="token operator">=</span> state_type<span class="token punctuation">,</span>
        total_rounds <span class="token operator">=</span> total_rounds<span class="token punctuation">,</span>
        computation_rounds <span class="token operator">=</span> computation_rounds<span class="token punctuation">)</span>
</code></pre><p>To run the MBQC and UBQC we only need <code>para</code></p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    mbqc_outcome <span class="token operator">=</span> run_mbqc<span class="token punctuation">(</span>para<span class="token punctuation">)</span>
    ubqc_outcome <span class="token operator">=</span> run_ubqc<span class="token punctuation">(</span>para<span class="token punctuation">)</span>
</code></pre><p>For the verification protocol we specify the type of <em>Server</em></p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    vbqc_outcome <span class="token operator">=</span> run_verification_simulator<span class="token punctuation">(</span>TrustworthyServer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>para<span class="token punctuation">)</span>
    vbqc_outcome <span class="token operator">=</span> run_verification_simulator<span class="token punctuation">(</span>TrustworthyServer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Terse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>para<span class="token punctuation">)</span>
</code></pre><p>Here the server is <code>TrustworthyServer</code>, so all results are done in a noiseless state and the server agent (simulated server not real one) is not interfering with the computation. The <code>Verbose</code> flag dictates the output to include extra details of the results [add content]. The <code>Terse</code> flag returns only whether the computation was <code>Ok</code> or <code>Abort</code>. For a <code>MaliciousServer</code>, meaning one that adds an additional angle to the updated angle basis for measurement.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    malicious_angles <span class="token operator">=</span> <span class="token constant">π</span><span class="token operator">/</span><span class="token number">2</span>
    malicious_vbqc_outcome <span class="token operator">=</span> run_verification_simulator<span class="token punctuation">(</span>MaliciousServer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>para<span class="token punctuation">,</span>malicious_angles<span class="token punctuation">)</span>
</code></pre><p>The <code>malicious_angles</code> can be a single angle, applied uniformly to all qubits, or a vector of angles applied specifically to each qubit according to order from <code>1</code> to <code>num_vertices</code>.</p>
<p>To add noise to the verification, there are some ready-made models to choose from, damping, dephasing, depolarising, pauli, (need to finalise these: Kraus, two qubit, density matrix mixing, N qubit kruas).</p>
<p>Depending on the noise, there are constraints based on the theory of the noise, so lets scale noise <code>p_scale = 0.05</code>. Lets do a damping noise model.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    p <span class="token operator">=</span> <span class="token punctuation">[</span>p_scale<span class="token operator">*</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> vertices<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    model <span class="token operator">=</span> Damping<span class="token punctuation">(</span>Quest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>SingleQubit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span>
    server <span class="token operator">=</span> NoisyServer<span class="token punctuation">(</span>model<span class="token punctuation">)</span>
    vbqc_outcome <span class="token operator">=</span> run_verification_simulator<span class="token punctuation">(</span>server<span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>para<span class="token punctuation">)</span>
</code></pre><p>Here we generate <code>n</code> random probabilities, which will be applied to each qubit in the graph. A noise model is defined by the <code>struct</code> representing the noise, in this case, <code>Damping()</code>. Each noise model only takes three arguments. In future plans different quantum computing backends will be used (BYOQ - Bring Your Own Quantum), so the QC emulator is specified, <code>Quest</code> in this case. The noise model is applied to individual qubits, the second argument is <code>SingleQubit</code>, as opposed to <code>TwoQubit</code> or <code>NQubit</code>, the latter  are not in use yet. Finally, the probability, like before this can be a scalar or a vector, the scalar being applied uniformly as before. The <code>model</code> is a container, which is stored inside the type of server, here <code>NoisyServer</code>. Then the same simulator is called <code>run_verification_simulator</code> to run the protocol, but with the specified noise model. The following show a similar implementation.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    <span class="token comment"># Dephasing</span>
    p <span class="token operator">=</span> <span class="token punctuation">[</span>p_scale<span class="token operator">*</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> vertices<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    model <span class="token operator">=</span> Dephasing<span class="token punctuation">(</span>Quest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>SingleQubit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span>
    server <span class="token operator">=</span> NoisyServer<span class="token punctuation">(</span>model<span class="token punctuation">)</span>
    vbqc_outcome <span class="token operator">=</span> run_verification_simulator<span class="token punctuation">(</span>server<span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>para<span class="token punctuation">)</span>

    <span class="token comment"># Depolarising</span>
    p <span class="token operator">=</span> <span class="token punctuation">[</span>p_scale<span class="token operator">*</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> vertices<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    model <span class="token operator">=</span> Depolarising<span class="token punctuation">(</span>Quest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>SingleQubit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span>
    server <span class="token operator">=</span> NoisyServer<span class="token punctuation">(</span>model<span class="token punctuation">)</span>
    vbqc_outcome <span class="token operator">=</span> run_verification_simulator<span class="token punctuation">(</span>server<span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>para<span class="token punctuation">)</span>

    <span class="token comment"># Pauli</span>
    p_xyz<span class="token punctuation">(</span>p_scale<span class="token punctuation">)</span> <span class="token operator">=</span> p_scale <span class="token punctuation">.</span><span class="token operator">*</span> <span class="token punctuation">[</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    p <span class="token operator">=</span> <span class="token punctuation">[</span>p_xyz<span class="token punctuation">(</span>p_scale<span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> vertices<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    model <span class="token operator">=</span> Pauli<span class="token punctuation">(</span>Quest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>SingleQubit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span>
    server <span class="token operator">=</span> NoisyServer<span class="token punctuation">(</span>model<span class="token punctuation">)</span>
    vbqc_outcome <span class="token operator">=</span> run_verification_simulator<span class="token punctuation">(</span>server<span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>para<span class="token punctuation">)</span>
</code></pre><p>The Pauli noise acts on the x,y and z axis to there are three probabilities for each qubit. In addition to each simulator being able to run a single noise model, we can run a list of noise models.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    <span class="token comment"># Vector of noise models</span>
    model_vec <span class="token operator">=</span> <span class="token punctuation">[</span>Damping<span class="token punctuation">,</span>Dephasing<span class="token punctuation">,</span>Depolarising<span class="token punctuation">,</span>Pauli<span class="token punctuation">]</span>
    p_damp <span class="token operator">=</span> <span class="token punctuation">[</span>p_scale<span class="token operator">*</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> vertices<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    p_deph <span class="token operator">=</span> <span class="token punctuation">[</span>p_scale<span class="token operator">*</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> vertices<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    p_depo <span class="token operator">=</span> <span class="token punctuation">[</span>p_scale<span class="token operator">*</span>rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> vertices<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    p_pauli <span class="token operator">=</span> <span class="token punctuation">[</span>p_xyz<span class="token punctuation">(</span>p_scale<span class="token punctuation">)</span> <span class="token keyword keyword-for">for</span> i <span class="token keyword keyword-in">in</span> vertices<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    prob_vec <span class="token operator">=</span> <span class="token punctuation">[</span>p_damp<span class="token punctuation">,</span>p_deph<span class="token punctuation">,</span>p_depo<span class="token punctuation">,</span>p_pauli<span class="token punctuation">]</span>

    models <span class="token operator">=</span> Vector<span class="token punctuation">{</span>NoiseModels<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-for">for</span> m <span class="token keyword keyword-in">in</span> eachindex<span class="token punctuation">(</span>model_vec<span class="token punctuation">)</span>        push<span class="token operator">!</span><span class="token punctuation">(</span>models<span class="token punctuation">,</span>model_vec<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">(</span>Quest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>SingleQubit<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>prob_vec<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword keyword-end">end</span>
    server <span class="token operator">=</span> NoisyServer<span class="token punctuation">(</span>models<span class="token punctuation">)</span>
    vbqc_outcome <span class="token operator">=</span> run_verification_simulator<span class="token punctuation">(</span>server<span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>para<span class="token punctuation">)</span>
</code></pre><p>If we want to run general Kraus maps, we can do so on single, double and <code>n</code> qubit levels - <strong>NEED TO DO</strong>. If we have a density matrix with a specified noise model, we can mix that with the algorithm as well - <strong>NEED TO DO</strong>.</p>
<h2 id="inside-the-verification-simulator">Inside the verification simulator </h2>
<p>Let us look closer at the <code>TrustWorthy</code> <code>Verbose</code> simulator function.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    <span class="token keyword keyword-function">function</span> run_verification_simulator<span class="token punctuation">(</span><span class="token punctuation">::</span>TrustworthyServer<span class="token punctuation">,</span><span class="token punctuation">::</span>Verbose<span class="token punctuation">,</span>para<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword keyword-end">end</span>
</code></pre><p>Currently, the trapification strategy is to generate a random colouring of the presented graph, based on a greedy heuristic [Cite graphs package?]. Naively the choice is made such that out of <code>100</code> repetitions, the best coloring is picked. The computation round is simply one colour for all vertices.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    computation_colours <span class="token operator">=</span> ones<span class="token punctuation">(</span>nv<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p>For each coloured vertex, a 2-colour graph is formed, that of the colored vertex and a colour for the remaining vertices. Hence, a 4-colour graph, can be split into 4 distinct graphs according to the colouring.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    test_colours <span class="token operator">=</span> get_vector_graph_colors<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">;</span>reps<span class="token operator">=</span>reps<span class="token punctuation">)</span>
</code></pre><p>To determine the number of acceptable failed rounds a value is computed dependent on the BQP error, the number of colours and the distribution of test rounds to total rounds.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    chroma_number <span class="token operator">=</span> length<span class="token punctuation">(</span>test_colours<span class="token punctuation">)</span>
    bqp <span class="token operator">=</span> InherentBoundedError<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span>
    test_rounds_theshold <span class="token operator">=</span> compute_trap_round_fail_threshold<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>total_rounds<span class="token punctuation">]</span><span class="token punctuation">,</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>computation_rounds<span class="token punctuation">]</span><span class="token punctuation">,</span>chroma_number<span class="token punctuation">,</span>bqp<span class="token punctuation">)</span> 
</code></pre><p>Recall that the <code>forward_flow</code> is user defined, then the <code>backward_flow</code> is numerically computed./</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    backward_flow<span class="token punctuation">(</span>vertex<span class="token punctuation">)</span> <span class="token operator">=</span> compute_backward_flow<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">,</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>forward_flow<span class="token punctuation">]</span><span class="token punctuation">,</span>vertex<span class="token punctuation">)</span>
</code></pre><p>These computations along with the remaining values from <code>para</code> are stored in a <code>NamedTuple</code> which is used to create a <code>struct</code> wrapping all variables in a defined type.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    p <span class="token operator">=</span> <span class="token punctuation">(</span>
        input_indices <span class="token operator">=</span>  para<span class="token punctuation">[</span><span class="token punctuation">:</span>input<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span>indices<span class="token punctuation">]</span><span class="token punctuation">,</span>
        input_values <span class="token operator">=</span> para<span class="token punctuation">[</span><span class="token punctuation">:</span>input<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">:</span>values<span class="token punctuation">]</span><span class="token punctuation">,</span>
        output_indices <span class="token operator">=</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>output<span class="token punctuation">]</span><span class="token punctuation">,</span>
        graph<span class="token operator">=</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>graph<span class="token punctuation">]</span><span class="token punctuation">,</span>
        computation_colours<span class="token operator">=</span>computation_colours<span class="token punctuation">,</span>
        test_colours<span class="token operator">=</span>test_colours<span class="token punctuation">,</span>
        secret_angles<span class="token operator">=</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>secret_angles<span class="token punctuation">]</span><span class="token punctuation">,</span>
        forward_flow <span class="token operator">=</span> para<span class="token punctuation">[</span><span class="token punctuation">:</span>forward_flow<span class="token punctuation">]</span><span class="token punctuation">,</span>
        backward_flow<span class="token operator">=</span>backward_flow<span class="token punctuation">)</span>
        
    client_resource <span class="token operator">=</span> create_graph_resource<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
</code></pre><p>The <code>round_types</code> is a random permutation of <code>structs</code> <code>ComputationRound</code> and <code>TestRound</code> on the exact number of each.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    round_types <span class="token operator">=</span> draw_random_rounds<span class="token punctuation">(</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>total_rounds<span class="token punctuation">]</span><span class="token punctuation">,</span>para<span class="token punctuation">[</span><span class="token punctuation">:</span>computation_rounds<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><p>The type held by <code>round_types</code> is a <code>Vector</code>, which is iterated through to execute rounds determined by element of the iterator. The function <code>run_verification</code> executes the protocol for each round and return a vector of <code>MetaGraphs</code> for each round.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    rounds_as_graphs <span class="token operator">=</span> run_verification<span class="token punctuation">(</span>
        Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Server<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        round_types<span class="token punctuation">,</span>client_resource<span class="token punctuation">,</span>
        para<span class="token punctuation">[</span><span class="token punctuation">:</span>state_type<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><p>The <code>MetaGraph</code> is the core data structure for any given MBQC computation. Due to it's inherent graph and vertex properties, mulitple dispatch was used to perform appropriate computation across vertices in a graph. Results for the <code>Verbose</code> flag ar the outcomes with the results for acceptable round or failed round.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>        test_verification <span class="token operator">=</span> verify_rounds<span class="token punctuation">(</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>TestRound<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Terse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rounds_as_graphs<span class="token punctuation">,</span>test_rounds_theshold<span class="token punctuation">)</span>
        computation_verification <span class="token operator">=</span> verify_rounds<span class="token punctuation">(</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ComputationRound<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Terse<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rounds_as_graphs<span class="token punctuation">)</span>
        test_verification_verb <span class="token operator">=</span> verify_rounds<span class="token punctuation">(</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>TestRound<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rounds_as_graphs<span class="token punctuation">,</span>test_rounds_theshold<span class="token punctuation">)</span>
        computation_verification_verb <span class="token operator">=</span> verify_rounds<span class="token punctuation">(</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ComputationRound<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Verbose<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rounds_as_graphs<span class="token punctuation">)</span>
        mode_outcome <span class="token operator">=</span> get_mode_output<span class="token punctuation">(</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ComputationRound<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>rounds_as_graphs<span class="token punctuation">)</span>
</code></pre><p>These results are returned as a <code>NamedTuple</code></p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>
        test_verification <span class="token operator">=</span> test_verification<span class="token punctuation">,</span>
        test_verification_verb <span class="token operator">=</span> test_verification_verb<span class="token punctuation">,</span>
        computation_verification <span class="token operator">=</span> computation_verification<span class="token punctuation">,</span>
        computation_verification_verb <span class="token operator">=</span> computation_verification_verb<span class="token punctuation">,</span>
        mode_outcome <span class="token operator">=</span> mode_outcome<span class="token punctuation">)</span>
</code></pre><p>Let's look closer at the verification function, <code>run_verification</code>.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code><span class="token keyword keyword-function">function</span> run_verification<span class="token punctuation">(</span><span class="token punctuation">::</span>Client<span class="token punctuation">,</span><span class="token punctuation">::</span>Server<span class="token punctuation">,</span>
    round_types<span class="token punctuation">,</span>client_resource<span class="token punctuation">,</span>state_type<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    round_graphs
    <span class="token keyword keyword-end">end</span>
</code></pre><p>As before, we take a <code>Client</code> and a <code>Server</code> type, the server can be replaced with a different type given a desired computation. We run the verification protocol over a vector of rounds.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    round_graphs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword keyword-for">for</span> round_type <span class="token keyword keyword-in">in</span> round_types
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        client_meta_graph <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        push<span class="token operator">!</span><span class="token punctuation">(</span>round_graphs<span class="token punctuation">,</span>client_meta_graph<span class="token punctuation">)</span>
    <span class="token keyword keyword-end">end</span>
</code></pre><p>For each <code>round_type</code> in the vector <code>round_types</code>, note <code>round_type</code> is either <code>TestRound</code> or <code>ComputationRound</code> and Julia's multiple dispatch will perform the appropriate functions based on said type, the computation is performed, details are mutated onto the property graph, <code>client_meta_graph</code> and stored in the vector <code>round_graphs</code>. Within each round several computations take place. First,</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    client_meta_graph <span class="token operator">=</span> generate_property_graph<span class="token operator">!</span><span class="token punctuation">(</span>
        Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        round_type<span class="token punctuation">,</span>
        client_resource<span class="token punctuation">,</span>
        state_type<span class="token punctuation">)</span>
</code></pre><p>a <code>client_meta_graph</code> is generated with the function <code>generate_property_graph!</code> which takes the <code>Client</code>, <code>round_type</code>, <code>client_resoure</code> and <code>state_type</code> as inputs. This function will be discussed further below. The <code>client_meta_graph</code> contains round specific values, the vertex angles, the forward and backward vertices according to the flow, allocation variables for measurement outcomes, the initialised state quatum register backed by QuEST. Note that no vertex is entangled, only initialised according the UBQC methdologies of client and server sepatation. To effect this disctinction the client quantum register and simple graph are extracted.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    client_graph <span class="token operator">=</span> produce_initialised_graph<span class="token punctuation">(</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>client_meta_graph<span class="token punctuation">)</span>
    client_qureg <span class="token operator">=</span> produce_initialised_qureg<span class="token punctuation">(</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>client_meta_graph<span class="token punctuation">)</span>
</code></pre><p>The the server resource is created, <code>create_resource</code>, using the <code>Server</code>, <code>client_graph</code> and <code>client_qureg</code> as inputs. The server side resource is where noise is added if that is the case and where the circuit is entangled according to the edge map of the underlying MBQC graph structure.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    server_resource <span class="token operator">=</span> create_resource<span class="token punctuation">(</span>Server<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>client_graph<span class="token punctuation">,</span>client_qureg<span class="token punctuation">)</span>
</code></pre><p>From here the server quantum state, or register is extracted from the server container, <code>server_resource</code>, thus, separationg of the client and the server is effected. We even extract the number ofqubits based on the server register.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    server_quantum_state <span class="token operator">=</span> server_resource<span class="token punctuation">[</span><span class="token string">"quantum_state"</span><span class="token punctuation">]</span>
    num_qubits_from_server <span class="token operator">=</span> server_quantum_state<span class="token punctuation">.</span>numQubitsRepresented
</code></pre><p>Now for the given round, which has entirely driven the specific values of the propetry graph, the UBQC computation can be performed.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    run_computation<span class="token punctuation">(</span>Client<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Server<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>client_meta_graph<span class="token punctuation">,</span>num_qubits_from_server<span class="token punctuation">,</span>server_quantum_state<span class="token punctuation">)</span>
</code></pre><p>The underlying register is still in effect, so to save loading and memory usage, we clear the state of the server register, ready to take on the next round of client side computation.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    initialise_blank_quantum_state<span class="token operator">!</span><span class="token punctuation">(</span>server_quantum_state<span class="token punctuation">)</span>
</code></pre><p>Now we come back to pushing the <code>client_meta_graph</code>,  which now holds all of the measurement outcomes, to the <code>round_graphs</code> vector. This is then returned at the end of the function call.</p>
<pre data-role="codeBlock" data-info="julia" class="language-julia julia"><code>    push<span class="token operator">!</span><span class="token punctuation">(</span>round_graphs<span class="token punctuation">,</span>client_meta_graph<span class="token punctuation">)</span>
</code></pre><p>The result is a vector of rounds. Further explanation is found at the GitHub repository.</p>
<p><strong>To Do</strong></p>
<ol>
<li>Finish QuEST.jl to acceptable degree</li>
<li>Add and complete documentation to package</li>
<li>Provide tutorials</li>
<li>Get QuEST.jl linked on QuEST homepage</li>
<li>Edit paper</li>
<li>Get checklist for JOSS</li>
<li>Complete checklist</li>
</ol>
<h1 id="citations">Citations </h1>
<p>Leave here for reference<br>
Citations to entries in paper.bib should be in<br>
<a href="http://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html">rMarkdown</a><br>
format.</p>
<p>If you want to cite a software repository URL (e.g. something on GitHub without a preferred<br>
citation) then you can do it with the example BibTeX entry below for @fidgit.</p>
<p>For a quick reference, the following citation commands can be used:</p>
<ul>
<li><code>@author:2001</code>  -&gt;  "Author et al. (2001)"</li>
<li><code>[@author:2001]</code> -&gt; "(Author et al., 2001)"</li>
<li><code>[@author1:2001; @author2:2001]</code> -&gt; "(Author1 et al., 2001; Author2 et al., 2002)"</li>
</ul>
<h1 id="figures">Figures </h1>
<p>Figures can be included like this:<br>
<img src="figure.png" alt="Caption for example figure.abel{fig:example}"><br>
and referenced from text using \autoref{fig:example}.</p>
<p>Figure sizes can be customized by adding an optional second parameter:<br>
<img src="figure.png" alt="Caption for example figure." width="20%"></p>
<h1 id="acknowledgements">Acknowledgements </h1>
<p>We acknowledge contributions from Brigitta Sipocz, Syrtis Major, and Semyeong<br>
Oh, and support from Kathryn Johnston during the genesis of this project.</p>
<h1 id="references">References </h1>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>