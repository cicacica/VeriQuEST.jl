<h1 id="summary">Summary</h1>
<p>Utilising remote computation resources when local availability does
not meet the users needs is currently in use for classical and cloud
computing. It is likely that quantum computing will also be accessed and
used as such. It is not unreasonable that computations, data and
algorithms run on powerful quantum servers be confidential, free from
harm and verifiable. Hence, delegated quantum computing is an important
pathway to extending QC usefulness. Security protocols for blind and
verifiable QC do exist and it has been shown that bounded-error quantum
polynomial (BQP) computations can be verified with little overhead,
other than computational repetitions, are composable and secure with
toleration to constant noise, called Robust Blind Verified Quantum
Computing (RBVQC). To emulate these known results, we introduce the
Julia package, <code>RobustBlindVerification.jl</code> (RBV). RBV is a
quantum verification emulator using Julia and the C library
<code>QuEST</code> (for QC emulation and noise modelling). To explore
the theoretical nature of RBVQC numerically, this software implements
measurement based quantum computing (MBQC), universal blind MBQC (UBQC)
and an RBVQC protocol.</p>
<p><strong>Refine and proof … <span class="citation"
data-cites="PRXQuantum.2.040302">(Leichtle et al.
2021)</span></strong></p>
<h1 id="statement-of-need">Statement of need</h1>
<p>The rise of quantum computers gives rise to a variety of path
dependent access points. Delegated quantum computing may likely be the
dominant means most can use to access a quantum computer. One party’s
access may require secrecy in their computation. Another party, or the
same, may need to verify results that computations are trustworty.
Formal methods in quantum verification have been developed in theory.
Many of these methods rely on quantum networks, mid-circuit measurement
and qubit capabilities beyond the current near-term offering. In
preparation for the aforementioned to become a reality, quanutm
emulators offer cheap computational access in many toy problems, along
with an ability to test theoretical results. High performance
computation utilises multiple CPUs or GPUs to approach the arymptotic
limit of classical computation in the emulation of the quantum
computers.</p>
<p>Most verification protocols rely on MBQC, due to the ability to
separate computational components through the use of projective
measurements. Herein lies a pain point. Many quantum computers today do
not readily offer mid-circuit measurement, which is key to MBQC. Furth
there are few MBQC emulators, and the ones that do exist (CITE Grapix,
others …) do not consider the paradigm of RBVQC. Specifically, there is
no impelementation to separate the concerns of the a so-call “client”
and “server”, nor is there the usage of interactive computation between
two parties.</p>
<p>RBV is to-date (and at the authors undersatnding) the only emulator
which implements a simulated blind quantum computation, let alone the
verification protool [cite]. Many quantum computing emulators also only
focus on the gate-based model, whilst some implement MBQC [Cite] many do
not allow for noise models beyond uncorrelated models, which do not
utilise density matrix backends. Many emulators are also focused on
python-based libraries [cite]. RBV is based in Julia and calls on a C
library. QuEST is a remarkable library that is capable of use
agnostically to the machinery accessing the library.</p>
<p>What else …. Cite …..</p>
<h1 id="core-features-and-functionality">Core features and
functionality</h1>
<p>The root QC paradigm of RVBQC is MBQC. Hence, a user, after initial
implementations, is able to run their given MBQC circuit and obtain
noiseless results. Further, without impelementing the multiple rounds of
the verification protocol, the user can take that same circuit and run
it blindly. The main feature of RBV is the implementation of the
protocol (<strong>CITE and reference in some consistent way</strong>).
Here the user is able to run the protocol with no noise, uncorrelated
noise, and specific noise models.</p>
<p>RBV uses QuEST, as has been mentioned. Further to this, QuEST was
compiled into the Julia package QuEST_jll. This was done with
BinaryBuilder.jl, and so is completely reproducible and even accessible
from the Julia general registry, if users wish to have direct access.
The package was compile with the default CMake options from the QuEST
GitHub repository (cite). Further, we created QuEST.jl to specifically
call all of the functions in the QuEST header file, making QuEST.jl a
completely wrapped package for users to emulate other functions at their
desire. [<strong>Needs to be completed and tested, or expression of
limitations made</strong>] Users are able to also call multiple threads
if needed in these computations. [<strong>What does this mean</strong>]
As QuEST is runnable in HPC a future Julia release will include this
functionality.</p>
<p>We present a basic tutorial on the usage of RBV along with targeted
functions explained.</p>
<p>To begin, if not already done so, download and install Julia in your
preferred method. Though lately JuliaUP is recommended. Then activate
the Julia project of the local directory location</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">using</span> <span class="bu">Pkg;</span> Pkg.activate(&quot;.&quot;)</span></code></pre></div>
<p>Add <code>RobustBlindVerification.jl</code></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>] add RobustBlindVerification</span></code></pre></div>
<p>To run, first decide the computational backend, either a state vector
or density matrix. These are <code>structs</code> named
<code>StateVector</code> and <code>DensityMatrix</code>.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>state_type <span class="op">=</span> <span class="fu">DensityMatrix</span>()</span></code></pre></div>
<p>Choose the number of rounds and the number of computational rounds
(the number of test rounds is the difference of computation from
total).</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>total_rounds,computation_rounds <span class="op">=</span> <span class="fl">100</span>,<span class="fl">50</span></span></code></pre></div>
<p>RBV uses <code>Graphs.jl</code> and <code>MetaGraphs.jl</code>, so
defining a graph uses that syntax. In this example we use the MBQC
version of the 2 qubit Gover oracle algorithm.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    num_vertices <span class="op">=</span> <span class="fl">8</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> <span class="fu">Graph</span>(num_vertices)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_edge!</span>(graph,<span class="fl">1</span>,<span class="fl">2</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_edge!</span>(graph,<span class="fl">2</span>,<span class="fl">3</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_edge!</span>(graph,<span class="fl">3</span>,<span class="fl">6</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_edge!</span>(graph,<span class="fl">6</span>,<span class="fl">7</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_edge!</span>(graph,<span class="fl">1</span>,<span class="fl">4</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_edge!</span>(graph,<span class="fl">4</span>,<span class="fl">5</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_edge!</span>(graph,<span class="fl">5</span>,<span class="fl">8</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_edge!</span>(graph,<span class="fl">7</span>,<span class="fl">8</span>)</span></code></pre></div>
<p>We can specify any classical inputs to be loaded into the algorithm
as well the output qubits.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    input <span class="op">=</span> (indices <span class="op">=</span> (),values <span class="op">=</span> ())</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> (<span class="fl">7</span>,<span class="fl">8</span>)</span></code></pre></div>
<p>There are algorithms for automatic flow detection, these have not
been implemented, so the user defines a function for the so-called
<em>forward flow</em>. The function is used to determine the
<em>backward flow</em>.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">forward_flow</span>(vertex)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        v_str <span class="op">=</span> <span class="fu">string</span>(vertex)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        forward <span class="op">=</span> <span class="fu">Dict</span>(</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;1&quot;</span> <span class="op">=&gt;</span><span class="fl">4</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;2&quot;</span> <span class="op">=&gt;</span><span class="fl">3</span>,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;3&quot;</span> <span class="op">=&gt;</span><span class="fl">6</span>,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;4&quot;</span> <span class="op">=&gt;</span><span class="fl">5</span>,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;5&quot;</span> <span class="op">=&gt;</span><span class="fl">8</span>,</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;6&quot;</span> <span class="op">=&gt;</span><span class="fl">7</span>,</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;7&quot;</span> <span class="op">=&gt;</span><span class="fl">0</span>,</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;8&quot;</span> <span class="op">=&gt;</span><span class="fl">0</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        forward[v_str]</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span></code></pre></div>
<p>Note: the internal structure of the <code>forward_flow</code> does
not matter, as long as vertex input returns vertex output
(<code>Int</code> type) and these values correspond to the graph, then
the user can define its choice of I/O for that function.</p>
<p>The secret angles are defined next. For the Grover algorithm, the
angles are curcial in its operation.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">generate_grover_secret_angles</span>(search<span class="op">::</span><span class="dt">String</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">Dict</span>(<span class="st">&quot;00&quot;</span><span class="op">=&gt;</span>(<span class="fl">1.0</span><span class="op">*</span><span class="cn">π</span>,<span class="fl">1.0</span><span class="op">*</span><span class="cn">π</span>),<span class="st">&quot;01&quot;</span><span class="op">=&gt;</span>(<span class="fl">1.0</span><span class="op">*</span><span class="cn">π</span>,<span class="fl">0</span>),<span class="st">&quot;10&quot;</span><span class="op">=&gt;</span>(<span class="fl">0</span>,<span class="fl">1.0</span><span class="op">*</span><span class="cn">π</span>),<span class="st">&quot;11&quot;</span><span class="op">=&gt;</span>(<span class="fl">0</span>,<span class="fl">0</span>)) <span class="op">|&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        x <span class="op">-&gt;</span> x[search] <span class="op">|&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        x <span class="op">-&gt;</span> [<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1.0</span><span class="op">*</span>x[<span class="fl">1</span>],<span class="fl">1.0</span><span class="op">*</span>x[<span class="fl">2</span>],<span class="fl">0</span>,<span class="fl">0</span>,<span class="fl">1.0</span><span class="op">*</span><span class="cn">π</span>,<span class="fl">1.0</span><span class="op">*</span><span class="cn">π</span>] <span class="op">|&gt;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        x <span class="op">-&gt;</span> <span class="fu">Float64</span>.(x)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span></code></pre></div>
<p>The function <code>generate_grover_secret_angles</code> defines the
angles associated to each vertex in the <code>graph</code> which is
dependent on the <code>search</code> input. Here we will define search
as <code>11</code></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    search <span class="op">=</span> <span class="st">&quot;11&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    secret_angles <span class="op">=</span> <span class="fu">generate_grover_secret_angles</span>(search)</span></code></pre></div>
<p>Names of inputs can vary, but they are all stored in a
<code>NamedTuple</code> as</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    para<span class="op">=</span> (</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">=</span>graph,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        forward_flow <span class="op">=</span> forward_flow,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        input <span class="op">=</span> input,</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        output <span class="op">=</span> output,</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        secret_angles<span class="op">=</span>secret_angles,</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        state_type <span class="op">=</span> state_type,</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        total_rounds <span class="op">=</span> total_rounds,</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        computation_rounds <span class="op">=</span> computation_rounds)</span></code></pre></div>
<p>To run the MBQC and UBQC we only need <code>para</code></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    mbqc_outcome <span class="op">=</span> <span class="fu">run_mbqc</span>(para)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    ubqc_outcome <span class="op">=</span> <span class="fu">run_ubqc</span>(para)</span></code></pre></div>
<p>For the verification protocol we specify the type of
<em>Server</em></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    vbqc_outcome <span class="op">=</span> <span class="fu">run_verification_simulator</span>(<span class="fu">TrustworthyServer</span>(),<span class="fu">Verbose</span>(),para)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    vbqc_outcome <span class="op">=</span> <span class="fu">run_verification_simulator</span>(<span class="fu">TrustworthyServer</span>(),<span class="fu">Terse</span>(),para)</span></code></pre></div>
<p>Here the server is <code>TrustworthyServer</code>, so all results are
done in a noiseless state and the server agent (simulated server not
real one) is not interfering with the computation. The
<code>Verbose</code> flag dictates the output to include extra details
of the results [add content]. The <code>Terse</code> flag returns only
whether the computation was <code>Ok</code> or <code>Abort</code>. For a
<code>MaliciousServer</code>, meaning one that adds an additional angle
to the updated angle basis for measurement.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    malicious_angles <span class="op">=</span> <span class="cn">π</span><span class="op">/</span><span class="fl">2</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    malicious_vbqc_outcome <span class="op">=</span> <span class="fu">run_verification_simulator</span>(<span class="fu">MaliciousServer</span>(),<span class="fu">Verbose</span>(),para,malicious_angles)</span></code></pre></div>
<p>The <code>malicious_angles</code> can be a single angle, applied
uniformly to all qubits, or a vector of angles applied specifically to
each qubit according to order from <code>1</code> to
<code>num_vertices</code>.</p>
<p>To add noise to the verification, there are some ready-made models to
choose from, damping, dephasing, depolarising, pauli, (need to finalise
these: Kraus, two qubit, density matrix mixing, N qubit kruas).</p>
<p>Depending on the noise, there are constraints based on the theory of
the noise, so lets scale noise <code>p_scale = 0.05</code>. Lets do a
damping noise model.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> [<span class="fu">p_scale*rand</span>() for i <span class="kw">in</span> <span class="fu">vertices</span>(para[<span class="op">:</span>graph])]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> <span class="fu">Damping</span>(<span class="fu">Quest</span>(),<span class="fu">SingleQubit</span>(),p)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    server <span class="op">=</span> <span class="fu">NoisyServer</span>(model)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    vbqc_outcome <span class="op">=</span> <span class="fu">run_verification_simulator</span>(server,<span class="fu">Verbose</span>(),para)</span></code></pre></div>
<p>Here we generate <code>n</code> random probabilities, which will be
applied to each qubit in the graph. A noise model is defined by the
<code>struct</code> representing the noise, in this case,
<code>Damping()</code>. Each noise model only takes three arguments. In
future plans different quantum computing backends will be used (BYOQ -
Bring Your Own Quantum), so the QC emulator is specified,
<code>Quest</code> in this case. The noise model is applied to
individual qubits, the second argument is <code>SingleQubit</code>, as
opposed to <code>TwoQubit</code> or <code>NQubit</code>, the latter are
not in use yet. Finally, the probability, like before this can be a
scalar or a vector, the scalar being applied uniformly as before. The
<code>model</code> is a container, which is stored inside the type of
server, here <code>NoisyServer</code>. Then the same simulator is called
<code>run_verification_simulator</code> to run the protocol, but with
the specified noise model. The following show a similar
implementation.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Dephasing</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> [<span class="fu">p_scale*rand</span>() for i <span class="kw">in</span> <span class="fu">vertices</span>(para[<span class="op">:</span>graph])]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> <span class="fu">Dephasing</span>(<span class="fu">Quest</span>(),<span class="fu">SingleQubit</span>(),p)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    server <span class="op">=</span> <span class="fu">NoisyServer</span>(model)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    vbqc_outcome <span class="op">=</span> <span class="fu">run_verification_simulator</span>(server,<span class="fu">Verbose</span>(),para)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Depolarising</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> [<span class="fu">p_scale*rand</span>() for i <span class="kw">in</span> <span class="fu">vertices</span>(para[<span class="op">:</span>graph])]</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> <span class="fu">Depolarising</span>(<span class="fu">Quest</span>(),<span class="fu">SingleQubit</span>(),p)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    server <span class="op">=</span> <span class="fu">NoisyServer</span>(model)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    vbqc_outcome <span class="op">=</span> <span class="fu">run_verification_simulator</span>(server,<span class="fu">Verbose</span>(),para)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pauli</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">p_xyz</span>(p_scale) <span class="op">=</span> p_scale <span class="op">.*</span> [<span class="fu">rand</span>(),<span class="fu">rand</span>(),<span class="fu">rand</span>()]</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> [<span class="fu">p_xyz</span>(p_scale) for i <span class="kw">in</span> <span class="fu">vertices</span>(para[<span class="op">:</span>graph])]</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> <span class="fu">Pauli</span>(<span class="fu">Quest</span>(),<span class="fu">SingleQubit</span>(),p)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    server <span class="op">=</span> <span class="fu">NoisyServer</span>(model)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    vbqc_outcome <span class="op">=</span> <span class="fu">run_verification_simulator</span>(server,<span class="fu">Verbose</span>(),para)</span></code></pre></div>
<p>The Pauli noise acts on the x,y and z axis to there are three
probabilities for each qubit. In addition to each simulator being able
to run a single noise model, we can run a list of noise models.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Vector of noise models</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    model_vec <span class="op">=</span> [Damping,Dephasing,Depolarising,Pauli]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    p_damp <span class="op">=</span> [<span class="fu">p_scale*rand</span>() for i <span class="kw">in</span> <span class="fu">vertices</span>(para[<span class="op">:</span>graph])]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    p_deph <span class="op">=</span> [<span class="fu">p_scale*rand</span>() for i <span class="kw">in</span> <span class="fu">vertices</span>(para[<span class="op">:</span>graph])]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    p_depo <span class="op">=</span> [<span class="fu">p_scale*rand</span>() for i <span class="kw">in</span> <span class="fu">vertices</span>(para[<span class="op">:</span>graph])]</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    p_pauli <span class="op">=</span> [<span class="fu">p_xyz</span>(p_scale) for i <span class="kw">in</span> <span class="fu">vertices</span>(para[<span class="op">:</span>graph])]</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    prob_vec <span class="op">=</span> [p_damp,p_deph,p_depo,p_pauli]</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    models <span class="op">=</span> <span class="fu">Vector</span><span class="dt">{NoiseModels}</span>()</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> m <span class="kw">in</span> <span class="fu">eachindex</span>(model_vec)        <span class="fu">push!</span>(models,model_vec[m](<span class="fu">Quest</span>(),<span class="fu">SingleQubit</span>(),prob_vec[m]))</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    server <span class="op">=</span> <span class="fu">NoisyServer</span>(models)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    vbqc_outcome <span class="op">=</span> <span class="fu">run_verification_simulator</span>(server,<span class="fu">Verbose</span>(),para)</span></code></pre></div>
<p>If we want to run general Kraus maps, we can do so on single, double
and <code>n</code> qubit levels - <strong>NEED TO DO</strong>. If we
have a density matrix with a specified noise model, we can mix that with
the algorithm as well - <strong>NEED TO DO</strong>.</p>
<h2 id="inside-the-verification-simulator">Inside the verification
simulator</h2>
<p>Let us look closer at the <code>TrustWorthy</code>
<code>Verbose</code> simulator function.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">run_verification_simulator</span>(<span class="op">::</span><span class="dt">TrustworthyServer</span>,<span class="op">::</span><span class="dt">Verbose</span>,para)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span></code></pre></div>
<p>Currently, the trapification strategy is to generate a random
colouring of the presented graph, based on a greedy heuristic [Cite
graphs package?]. Naively the choice is made such that out of
<code>100</code> repetitions, the best coloring is picked. The
computation round is simply one colour for all vertices.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    computation_colours <span class="op">=</span> <span class="fu">ones</span>(<span class="fu">nv</span>(para[<span class="op">:</span>graph]))</span></code></pre></div>
<p>For each coloured vertex, a 2-colour graph is formed, that of the
colored vertex and a colour for the remaining vertices. Hence, a
4-colour graph, can be split into 4 distinct graphs according to the
colouring.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    test_colours <span class="op">=</span> <span class="fu">get_vector_graph_colors</span>(para[<span class="op">:</span>graph];reps<span class="op">=</span>reps)</span></code></pre></div>
<p>To determine the number of acceptable failed rounds a value is
computed dependent on the BQP error, the number of colours and the
distribution of test rounds to total rounds.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    chroma_number <span class="op">=</span> <span class="fu">length</span>(test_colours)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    bqp <span class="op">=</span> <span class="fu">InherentBoundedError</span>(<span class="fl">1</span><span class="op">/</span><span class="fl">3</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    test_rounds_theshold <span class="op">=</span> <span class="fu">compute_trap_round_fail_threshold</span>(para[<span class="op">:</span>total_rounds],para[<span class="op">:</span>computation_rounds],chroma_number,bqp) </span></code></pre></div>
<p>Recall that the <code>forward_flow</code> is user defined, then the
<code>backward_flow</code> is numerically computed./</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">backward_flow</span>(vertex) <span class="op">=</span> <span class="fu">compute_backward_flow</span>(para[<span class="op">:</span>graph],para[<span class="op">:</span>forward_flow],vertex)</span></code></pre></div>
<p>These computations along with the remaining values from
<code>para</code> are stored in a <code>NamedTuple</code> which is used
to create a <code>struct</code> wrapping all variables in a defined
type.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> (</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>        input_indices <span class="op">=</span>  para[<span class="op">:</span>input][<span class="op">:</span>indices],</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        input_values <span class="op">=</span> para[<span class="op">:</span>input][<span class="op">:</span>values],</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        output_indices <span class="op">=</span>para[<span class="op">:</span>output],</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">=</span>para[<span class="op">:</span>graph],</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        computation_colours<span class="op">=</span>computation_colours,</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        test_colours<span class="op">=</span>test_colours,</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        secret_angles<span class="op">=</span>para[<span class="op">:</span>secret_angles],</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        forward_flow <span class="op">=</span> para[<span class="op">:</span>forward_flow],</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        backward_flow<span class="op">=</span>backward_flow)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    client_resource <span class="op">=</span> <span class="fu">create_graph_resource</span>(p)</span></code></pre></div>
<p>The <code>round_types</code> is a random permutation of
<code>structs</code> <code>ComputationRound</code> and
<code>TestRound</code> on the exact number of each.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    round_types <span class="op">=</span> <span class="fu">draw_random_rounds</span>(para[<span class="op">:</span>total_rounds],para[<span class="op">:</span>computation_rounds])</span></code></pre></div>
<p>The type held by <code>round_types</code> is a <code>Vector</code>,
which is iterated through to execute rounds determined by element of the
iterator. The function <code>run_verification</code> executes the
protocol for each round and return a vector of <code>MetaGraphs</code>
for each round.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    rounds_as_graphs <span class="op">=</span> <span class="fu">run_verification</span>(</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>        <span class="fu">Client</span>(),<span class="fu">Server</span>(),</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        round_types,client_resource,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        para[<span class="op">:</span>state_type])</span></code></pre></div>
<p>The <code>MetaGraph</code> is the core data structure for any given
MBQC computation. Due to it’s inherent graph and vertex properties,
mulitple dispatch was used to perform appropriate computation across
vertices in a graph. Results for the <code>Verbose</code> flag ar the
outcomes with the results for acceptable round or failed round.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>        test_verification <span class="op">=</span> <span class="fu">verify_rounds</span>(<span class="fu">Client</span>(),<span class="fu">TestRound</span>(),<span class="fu">Terse</span>(),rounds_as_graphs,test_rounds_theshold)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>        computation_verification <span class="op">=</span> <span class="fu">verify_rounds</span>(<span class="fu">Client</span>(),<span class="fu">ComputationRound</span>(),<span class="fu">Terse</span>(),rounds_as_graphs)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        test_verification_verb <span class="op">=</span> <span class="fu">verify_rounds</span>(<span class="fu">Client</span>(),<span class="fu">TestRound</span>(),<span class="fu">Verbose</span>(),rounds_as_graphs,test_rounds_theshold)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        computation_verification_verb <span class="op">=</span> <span class="fu">verify_rounds</span>(<span class="fu">Client</span>(),<span class="fu">ComputationRound</span>(),<span class="fu">Verbose</span>(),rounds_as_graphs)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        mode_outcome <span class="op">=</span> <span class="fu">get_mode_output</span>(<span class="fu">Client</span>(),<span class="fu">ComputationRound</span>(),rounds_as_graphs)</span></code></pre></div>
<p>These results are returned as a <code>NamedTuple</code></p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>        test_verification <span class="op">=</span> test_verification,</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        test_verification_verb <span class="op">=</span> test_verification_verb,</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        computation_verification <span class="op">=</span> computation_verification,</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        computation_verification_verb <span class="op">=</span> computation_verification_verb,</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        mode_outcome <span class="op">=</span> mode_outcome)</span></code></pre></div>
<p>Let’s look closer at the verification function,
<code>run_verification</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">run_verification</span>(<span class="op">::</span><span class="dt">Client</span>,<span class="op">::</span><span class="dt">Server</span>,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    round_types,client_resource,state_type)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    round_graphs</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span></code></pre></div>
<p>As before, we take a <code>Client</code> and a <code>Server</code>
type, the server can be replaced with a different type given a desired
computation. We run the verification protocol over a vector of
rounds.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>    round_graphs <span class="op">=</span> []</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> round_type <span class="kw">in</span> round_types</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        client_meta_graph <span class="op">=</span> <span class="op">...</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">push!</span>(round_graphs,client_meta_graph)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end</span></span></code></pre></div>
<p>For each <code>round_type</code> in the vector
<code>round_types</code>, note <code>round_type</code> is either
<code>TestRound</code> or <code>ComputationRound</code> and Julia’s
multiple dispatch will perform the appropriate functions based on said
type, the computation is performed, details are mutated onto the
property graph, <code>client_meta_graph</code> and stored in the vector
<code>round_graphs</code>. Within each round several computations take
place. First,</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    client_meta_graph <span class="op">=</span> <span class="fu">generate_property_graph!</span>(</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>        <span class="fu">Client</span>(),</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        round_type,</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        client_resource,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        state_type)</span></code></pre></div>
<p>a <code>client_meta_graph</code> is generated with the function
<code>generate_property_graph!</code> which takes the
<code>Client</code>, <code>round_type</code>,
<code>client_resoure</code> and <code>state_type</code> as inputs. This
function will be discussed further below. The
<code>client_meta_graph</code> contains round specific values, the
vertex angles, the forward and backward vertices according to the flow,
allocation variables for measurement outcomes, the initialised state
quatum register backed by QuEST. Note that no vertex is entangled, only
initialised according the UBQC methdologies of client and server
sepatation. To effect this disctinction the client quantum register and
simple graph are extracted.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    client_graph <span class="op">=</span> <span class="fu">produce_initialised_graph</span>(<span class="fu">Client</span>(),client_meta_graph)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    client_qureg <span class="op">=</span> <span class="fu">produce_initialised_qureg</span>(<span class="fu">Client</span>(),client_meta_graph)</span></code></pre></div>
<p>The the server resource is created, <code>create_resource</code>,
using the <code>Server</code>, <code>client_graph</code> and
<code>client_qureg</code> as inputs. The server side resource is where
noise is added if that is the case and where the circuit is entangled
according to the edge map of the underlying MBQC graph structure.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>    server_resource <span class="op">=</span> <span class="fu">create_resource</span>(<span class="fu">Server</span>(),client_graph,client_qureg)</span></code></pre></div>
<p>From here the server quantum state, or register is extracted from the
server container, <code>server_resource</code>, thus, separationg of the
client and the server is effected. We even extract the number ofqubits
based on the server register.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    server_quantum_state <span class="op">=</span> server_resource[<span class="st">&quot;quantum_state&quot;</span>]</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    num_qubits_from_server <span class="op">=</span> server_quantum_state.numQubitsRepresented</span></code></pre></div>
<p>Now for the given round, which has entirely driven the specific
values of the propetry graph, the UBQC computation can be performed.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">run_computation</span>(<span class="fu">Client</span>(),<span class="fu">Server</span>(),client_meta_graph,num_qubits_from_server,server_quantum_state)</span></code></pre></div>
<p>The underlying register is still in effect, so to save loading and
memory usage, we clear the state of the server register, ready to take
on the next round of client side computation.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">initialise_blank_quantum_state!</span>(server_quantum_state)</span></code></pre></div>
<p>Now we come back to pushing the <code>client_meta_graph</code>, which
now holds all of the measurement outcomes, to the
<code>round_graphs</code> vector. This is then returned at the end of
the function call.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode julia"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">push!</span>(round_graphs,client_meta_graph)</span></code></pre></div>
<p>The result is a vector of rounds. Further explanation is found at the
GitHub repository.</p>
<p><strong>To Do</strong> 1. Finish QuEST.jl to acceptable degree 2. Add
and complete documentation to package 3. Provide tutorials 4. Get
QuEST.jl linked on QuEST homepage 5. Edit paper 6. Get checklist for
JOSS 7. Complete checklist</p>
<h1 id="citations">Citations</h1>
<p>Leave here for reference Citations to entries in paper.bib should be
in <a
href="http://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html">rMarkdown</a>
format.</p>
<p>If you want to cite a software repository URL (e.g. something on
GitHub without a preferred citation) then you can do it with the example
BibTeX entry below for <span class="citation"
data-cites="fidgit">(<strong>fidgit?</strong>)</span>.</p>
<p>For a quick reference, the following citation commands can be used: -
<code>@author:2001</code> -&gt; “Author et al. (2001)” -
<code>[@author:2001]</code> -&gt; “(Author et al., 2001)” -
<code>[@author1:2001; @author2:2001]</code> -&gt; “(Author1 et al.,
2001; Author2 et al., 2002)”</p>
<h1 id="figures">Figures</h1>
<p>Figures can be included like this: <img src="figure.png"
alt="Caption for example figure." /> and referenced from text using
.</p>
<p>Figure sizes can be customized by adding an optional second
parameter: <img src="figure.png" style="width:20.0%"
alt="Caption for example figure." /></p>
<h1 id="acknowledgements">Acknowledgements</h1>
<p>We acknowledge contributions from Brigitta Sipocz, Syrtis Major, and
Semyeong Oh, and support from Kathryn Johnston during the genesis of
this project.</p>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
data-entry-spacing="0" role="list">
<div id="ref-PRXQuantum.2.040302" class="csl-entry" role="listitem">
Leichtle, Dominik, Luka Music, Elham Kashefi, and Harold Ollivier. 2021.
<span>“Verifying BQP Computations on Noisy Devices with Minimal
Overhead.”</span> <em>PRX Quantum</em> 2 (October): 040302. <a
href="https://doi.org/10.1103/PRXQuantum.2.040302">https://doi.org/10.1103/PRXQuantum.2.040302</a>.
</div>
</div>
